<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Harmonious JavaScript with ES6</title>
    <link rel="stylesheet" href="presentation.css">
  </head>
  <body>
    <textarea id="source">
name: intro
layout: true
class: center, middle, inverse
---
# Harmonious JavaScript with ES6*
.footnote[.red[*] EcmaScript 6, aka. JavaScript Next, aka. Harmony]
---
layout: false
name: myself

# about:me

.left-column[
**Jesper Haug Karsrud**

**Full stack developer**

**Knowit Reaktor Kyber**

**I love JavaScript**
]

.right-column[
@beyondsanity

github.com/jkarsrud
]
--

.image[![Umbraco CMS](images/umbracologo.png)]

---
layout: false
name: new
class: cf

# ES6 goodies for everyone!
.left-column[
- [arrows](https://github.com/lukehoban/es6features#arrows)
- [classes](https://github.com/lukehoban/es6features#classes)
- [enhanced object literals](https://github.com/lukehoban/es6features#enhanced-object-literals)
- [template strings](https://github.com/lukehoban/es6features#template-strings)
- [destructuring](https://github.com/lukehoban/es6features#destructuring)
- [default + rest + spread](https://github.com/lukehoban/es6features#default--rest--spread)
- [let + const](https://github.com/lukehoban/es6features#let--const)
- [iterators + for..of](https://github.com/lukehoban/es6features#iterators--forof)
- [generators](https://github.com/lukehoban/es6features#generators)
- [comprehensions](https://github.com/lukehoban/es6features#comprehensions)
- [unicode](https://github.com/lukehoban/es6features#unicode)
- [modules](https://github.com/lukehoban/es6features#modules)
]
.right-column[
- [module loaders](https://github.com/lukehoban/es6features#module-loaders)
- [map + set + weakmap + weakset](https://github.com/lukehoban/es6features#map--set--weakmap--weakset)
- [proxies](https://github.com/lukehoban/es6features#proxies)
- [symbols](https://github.com/lukehoban/es6features#symbols)
- [subclassable built-ins](https://github.com/lukehoban/es6features#subclassable-built-ins)
- [promises](https://github.com/lukehoban/es6features#promises)
- [math + number + string + object APIs](https://github.com/lukehoban/es6features#math--number--string--object-apis)
- [binary and octal literals](https://github.com/lukehoban/es6features#binary-and-octal-literals)
- [reflect api](https://github.com/lukehoban/es6features#reflect-api)
- [tail calls](https://github.com/lukehoban/es6features#tail-calls)
]

???
This is all of the new stuff that's in ES6

I'll go through some of the — IMO — nicest/most useful ones

** There are other hidden features in my slides too, so pay attention **

---
name: arrows
class: center, middle

#Arrows (`=>`)

???
- Similar syntax to what we find in C# lamdas. Also in Java8 and CoffeeScript
- Expressions and statements
- `this` shares the lexical scope of surrounding code

---

#Arrows

## Expressions

.left-column[
#### Pre-ES6
```js
var mapped = arr.map(function(x) {
  return x + 1;
});
var mapped2 = arr.map(function(x, i) {
  return x + i;
});
```
]

.right-column[
#### ES6
```js
var mapped = arr.map(x => x + 1);
var mapped2 = arr.map((x, i) => x + i);
```
]

???
- Similar syntax to what we find in C# lamdas. Also in Java8 and CoffeeScript
- Expressions and statements
- `this` shares the lexical scope of surrounding code

---
#Arrows

## Statement bodies
.left-column[
#### Pre-ES6
```js
arr.forEach(function(x) {
  if(x % 3 === 0)
    threes.push(x)
});
```
]

.right-column[
#### ES6
```js
arr.forEach(x => {
  if(x % 3 === 0)
    threes.push(x)
});
```
]
???
Not much difference, but it's there ;)

---
#Arrows

## Lexical `this`
.left-column.smaller[
#### Pre-ES6
```js
var conference = {
  _name: "KDS 2014",
  _attendees: [],
  printAttendees: function() {
    var that = this;
    this._attendees.forEach(function(a) {
      console.log(a + ' is attending ' that._name);
    });
  }
};
```
]

.right-column.smaller[
#### ES6
```js
var conference = {
  _name: "KDS 2014",
  _attendees: [],
  printAttendees() {
    this._attendees.forEach(a =>
      console.log(a + ' is attending ' this._name));
  }
};
```
]

---
name: classes
class: center, middle

#Classes

---

#Classes

```js
class Car {
  constructor(make) {
    this.make = make;
    this.currentSpeed = 30;
  }

  printCurrentSpeed() {
    console.log(this.make +
      ' is going ' + this.currentSpeed +
      'km/h');
  }

  static revEngine() {
    console.log('Vrooom!');
  }
}
```

???

* Sugar on top of the prototype-based OO that we have today
* Constructors and static methods

**NEXT SLIDE**

---

#Classes

```js
class RaceCar extends Car {
  constructor(make, topSpeed) {
    super(make); // call base class constructor
    this.topSpeed = topSpeed;
  }

  goFullSpeed() {
    this.currentSpeed = this.topSpeed;
  }
}
```

???

* nice inheritance syntax without the prototype assignment of today
* Also gives us nice syntax for calling the base/super class (super)

**NEXT SLIDE**

---

#Classes

```js
let bugatti = new RaceCar('Bugatti Veyron', 430);

Car.revEngine();
// Vrooom

bugatti.printCurrentSpeed();
// Bugatti Veyron is going 30 km/h

bugatti.goFullSpeed();
bugatti.printCurrentSpeed();
// Bugatti Veyron is going 430 km/h
```

---
name: modules
class: center, middle

#Modules

???
* Finally a standardized module definition!
* CommonJS/node.js inspired syntax
* Named exports/imports
  - If you've worked with Node.js you know how this works*
* Default exports (like module.exports in node)

---

#Modules

.left-column.smallest[
CommonJS/Node

```js
var path = require('path');
var fs = require('fs');


module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
  // ...
  p = path.resolve(p);
  // ...
  mkdirP(path.dirname(p), opts, function (er, made) {
    // ...
  })
  // ...
}

// ...

mkdirP.sync = function sync (p, opts, made) {
  // ...
  p = path.resolve(p);
  // ...
  made = sync(path.dirname(p), opts, made);
  // ...
}
```
]

.right-column.smallest[
ES6 Module

```js
import { resolve, dirname } from "path";
import * as fs from "fs";

/* aliases present in the original */
export { mkdirP as mkdirp, mkdirP };

export default function mkdirP (p, opts, f, made) {
  // ...
  p = resolve(p);
  // ...
  mkdirP(dirname(p), opts, function (er, made) {
    // ...
  })
  // ...
}

// ...

export function sync (p, opts, made) {
  // ...
  p = resolve(p);
  // ...
  made = sync(dirname(p), opts, made);
  // ...
}
```
]

???
* Finally a standardized module definition!
* CommonJS/node.js inspired syntax
* Named exports/imports
  - If you've worked with Node.js you know how this works*
* Default exports (like module.exports in node)

---
name: promises
class: center, middle

#Promises

???
* Async pattern - like async await in C#
* A promise that a value will be there some time in the future
* Accomplishes the same thing as callbacks, but without callback hell
* Improved readability through method chaining and proper error handling*
---

#Promises

```js
function timeout(duration = 0) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, duration);
    })
}

var p = timeout(1000).then(() => {
    return timeout(2000);
}).then(() => {
    throw new Error("hmm");
}).catch(err => {
    return Promise.all([timeout(100), timeout(200)]);
})
```

???
* Async pattern - like async await in C#
* A promise that a value will be there some time in the future
* Accomplishes the same thing as callbacks, but without callback hell
* Improved readability through method chaining and proper error handling*

---

#Promises

```js
var promises = [2, 3, 5, 7, 11, 13].map(id => {
  return getJSON("/post/" + id + ".json");
});

Promise.all(promises).then(posts => {
  // posts contains an array of results for the given promises
  view.render(posts);
}).catch(reason => {
  // if any of the promises fails.
  throw new Error(reason);
});
```

???
As seen in the previous slide, you can also wait for all arrays to resolve before continuing

---
name: blockscope
class: center, middle

#Block scoping

???
* JavaScript scoping is hard, mostly because of:
  - global vs function scope
* We now have the `let` keyword to help us
* We also have proper constants through `const`
---

#Block scoping

`let` is the new `var`

`const` are real constants

```js
function f() {
  {
    let x;
    {
      // okay, block scoped name
      const x = "sneaky";
      // error, const
      x = "foo";
    }
    // error, already declared in block
    let x = "inner";
  }
}
```

???
* JavaScript scoping is hard, mostly because of:
  - global vs function scope
* We now have the `let` keyword to help us
* We also have proper constants through `const`
---
#Block scoping

```js
var num = 0; //globally scoped

for (let i = 0; i < 10; i++) { //i is block scoped
  num += i;
  console.log('value of i in block: ' + i);
}

console.log('Is i defined here?: ' + (typeof i !== 'undefined')); //Is i defined here?: false
```

???
* JavaScript scoping is hard, mostly because of:
  - global vs function scope
* We now have the `let` keyword to help us
* We also have proper constants through `const`

---
name: awesome
class: awesome, center, middle, inverse

# AWESOME

## And you can use it right now

---
class: center, middle
# How?

By transpiling your code, of course!

---
class: center, middle

# Traceur
<img src="images/traceur.svg" alt="Traceur logo" width="200px">

???
#Traceur compiler:

Traceur is a JavaScript.next-to-JavaScript-of-today compiler that allows you to use features from the future today

* CLI for transpiling
* Also has tasks for Grunt and Gulp
---
class: esnext, center, middle

# esnext

Tomorrow’s JavaScript syntax today

???
# ESNext

## What is it?

* Allow using future JavaScript syntax today.
* Require as little runtime code as possible.
* Generate human-readable code.*

##What it's not?

* Provide polyfills for future JavaScript APIs.
* Line-by-line equivalence from source to compiled.

Highly recommend the esnext repo
---
# esnext

* Arrows: [es6-arrow-function](https://github.com/esnext/es6-arrow-function)
* Classes: [es6-class](https://github.com/esnext/es6-class)
* Block scoping: —
* Modules: [es6-module-transpiler](https://github.com/esnext/es6-module-transpiler)
* Promises: Nope, no polyfills

???
* Arrows: es6-arrow-function
* Classes: es6-class
* Block scoping: In the TODO-list
* Modules: es6-module-transpiler
  - Using it every day on Altibox - transpiling to AMD with custom loader
  - Ember.JS is using them internally in the library
  - Module code is future-proof, when it's implemented in your browsers, you remove the build step
* Promises:
  - Browser support is getting there, latest Chrome and Firefox has native support for Promises already
  - Loads of libraries to give you support for it already, RSVP.js is one of the best.
    - Adds a couple of nice things on top the spec too

---
# Credits and links

- Luke Hoban for http://git.io/es6features
- Square for https://github.com/esnext/esnext
- The spec - https://people.mozilla.org/~jorendorff/es6-draft.html
- RSVP.js - https://github.com/tildeio/rsvp.js
    </textarea>
    <script src="js/remark-latest.min.js"></script>
    <script>
      var hljs = remark.highlighter.js;
      var slides = remark.create({
        ratio: '16:9',
        highlightStyle: 'github'
      });
    </script>
  </body>
</html>
